from typing import List, Optional

from smartmeterdecode import fastframecheck as fastframecheck

class HdlcFrameHeader:
    def __init__(self, frame: HdlcFrame) -> None: ...
    def update(self) -> None: ...
    @property
    def frame_format(self) -> Optional[int]: ...
    @property
    def frame_format_type(self) -> Optional[int]: ...
    @property
    def segmentation(self) -> Optional[bool]: ...
    @property
    def frame_length(self) -> Optional[int]: ...
    @property
    def destination_address(self) -> Optional[bytearray]: ...
    @property
    def source_address(self) -> Optional[bytearray]: ...
    @property
    def control(self) -> Optional[int]: ...
    @property
    def header_check_sequence(self) -> Optional[int]: ...
    @property
    def information_position(self) -> Optional[int]: ...

class HdlcFrame:
    def __init__(self) -> None: ...
    MAX_FRAME_LENGTH: int = ...
    def __len__(self) -> int: ...
    def append(self, byte: int) -> None: ...
    @property
    def frame_data(self) -> bytearray: ...
    @property
    def is_good_ffc(self) -> bool: ...
    @property
    def is_expected_length(self) -> bool: ...
    @property
    def header(self) -> HdlcFrameHeader: ...
    @property
    def frame_check_sequence(self) -> Optional[int]: ...
    @property
    def information(self) -> Optional[bytearray]: ...

class HdlcFrameReader:
    CONTROL_ESCAPE: int = ...
    FLAG_SEQUENCE: int = ...
    def __init__(self, use_octet_stuffing: bool=..., use_abort_sequence: bool=...) -> None: ...
    @property
    def unescape_next(self) -> bool: ...
    @property
    def is_in_hunt_mode(self) -> bool: ...
    def read(self, data_chunk: bytes) -> List[HdlcFrame]: ...

class _ReaderBuffer:
    def __init__(self) -> None: ...
    @property
    def is_available(self) -> bool: ...
    def pop(self) -> Optional[int]: ...
    def extend(self, data_chunk: bytes) -> None: ...
    def trim_buffer_to_current_position(self) -> None: ...
    def trim_buffer_to_flag_or_end(self) -> None: ...
