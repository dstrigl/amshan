import typing
from abc import ABCMeta, abstractmethod
from asyncio import (AbstractEventLoop, BaseProtocol, BaseTransport, Queue,
                     ReadTransport)
from typing import Any, Callable, ClassVar, Optional, Tuple

from smartmeterdecode import hdlc as hdlc

class BackOffStrategy(metaclass=ABCMeta):
    DEFAULT_MAX_DELAY_SEC: int = ...
    @abstractmethod
    def failure(self) -> None: ...
    @abstractmethod
    def reset(self) -> None: ...
    @property
    @abstractmethod
    def current_delay_sec(self) -> int: ...

class ExponentialBackOff(BackOffStrategy):
    max_delay: int = ...
    def __init__(self) -> None: ...
    def failure(self) -> None: ...
    def reset(self) -> None: ...
    @property
    def current_delay_sec(self) -> int: ...

class SmartMeterProtocol(ReadTransport):
    total_instance_counter: ClassVar[int] = ...
    queue: Queue = ...
    id: int = ...
    def __init__(self, queue: Queue, frame_reader: hdlc.HdlcFrameReader=...) -> None: ...
    @property
    def done(self) -> typing.Awaitable: ...
    def connection_made(self, transport: BaseTransport) -> None: ...
    def connection_lost(self, exc: Optional[Exception]) -> None: ...
    def data_received(self, data: bytes) -> None: ...
    def eof_received(self) -> bool: ...

class ConnectionManager:
    DEFAULT_CONNECTION_LOST_BACK_OFF_THRESHOLD: int = ...
    DEFAULT_CONNECTION_LOST_BACK_OFF_SLEEP_SEC: int = ...
    back_off_connect_error: BackOffStrategy = ...
    connection_lost_back_off_threshold: int = ...
    connection_lost_back_off_sleep_sec: int = ...
    def __init__(self, connection_factory: Callable[[], Tuple[BaseTransport, BaseProtocol]]) -> None: ...
    def close(self) -> None: ...
    async def connect_loop(self) -> None: ...

async def create_meter_tcp_connection(queue: Queue, loop: Optional[AbstractEventLoop]=..., *args: Any, **kwargs: Any) -> Tuple[BaseTransport, BaseProtocol]: ...
